
■　サーバー設計の考え方

いま、ひとつのServerに対して、二つのClientがぶら下がり、対戦を行なう場合について考えてみよう。
この二つのClientが存在する仮想的な“部屋”というものを考える。

たとえば、将棋ゲームで言えば対局室がこれに相当する。部屋にあとから来たユーザー(Client)も、
そこまでの対局棋譜が閲覧できなければならない。

条件を整理していこう。

まず、

・Client間の通信は、つねにServerを介して行なわれる。

ただし、今回の場合、

・ServerのCPU負荷の軽減のため、Server側に、ゲームの内部のいかなる判断もさせたくない
・Server側は、multi-threadは用いない。ひとつのconnectionずつ逐次的に処理を行なう

また、ClientがServerに対して出せる要求は、以下のものに限定する。

・push_room_message(byte[])
	卓(部屋)のメッセージを積む。
	
	その部屋に居るほかのユーザーには、ここで積まれたメッセージは
	自動的にbroadcastされる。
	
	あとから入ってきたユーザーには、
	部屋に積まれているメッセージを1番目のものから自動的に渡される。
	
・reset_room_message
　　卓メッセージをすべてクリアする。

Client同士は、push_room_messageを用いて互いに通信を行なわなければならない。

Clientの状態遷移は、FSA(有限状態オートマトン)で定義されていると考えると良い。

たとえば、Client 1が [GameStartRequest] をサーバーに送信するとする。
送信はもちろん、push_room_messageで行なわれる。

Client 2は、[ok]を返すとする。そうするとゲームがはじまり、Client 1は状態A に遷移するとする。

これを FSAで書くと、

    [GameStartRequest送信] ----->  [状態A]
                         ok

となる。Client 2側から見れば、

    [待ち状態] ----------> [ok送信] ----->[状態B]
			   GameStartRequest

となる。

しかし、Client 1がGameStartRequestを送ると同時に Client 2も GameStartRequestを送るかも知れない。
こうなったときは、 Client が Host(≒room master)ならば、それを無視して、状態Aに遷移、
Client が guest(≒ room masterではない)ならば、それを無視して状態Bに遷移するとする。

これをFSAで書くとClient1は

    [GameStartRequest送信] ----->  [状態A]
              |              ok        ↑
              |                         | はい
               ----------------->    Host？  ----> [状態B]
                GameStartRequest　　　　　　いいえ

となる。

しかし、よく考えると、Client1,2の動作は統合できて、

Client 1,2
    [待ち状態]  --------->   [GameStartRequest送信] -----> [状態A]
　　　　|　　　　ユーザー入力     |                  ok
　　　　|                         |GameStartRequest      
　　　　|　　　　　　　　　　　　↓
　　　　---------------------> Host？ ----> [状態A]
　　　　GameStartRequest        |    はい
　　　　                        |
　　　　                        |いいえ
　　　　                        ----------> [状態B]
　
　のようになるかも知れない。状態遷移に関してはテキトーに書いている。あまり深く考えないで欲しい。
　
　ともかく、この部分の設計のコツとしては
　
　・FSAで考える。
　・コマンド(メッセージ)を定義する。
　・それぞれの状態において、相手からは考えられうるすべてのコマンドが送られてきうる。
　・FSA上で遷移の抜けがないかを確認する。
　
　ということが大切である。上の例では、「GameStartRequest」と、それに対する「ok」responseという
　2つのメッセージしか定義されていないが、待ち状態を含めると、かなりややこしい遷移を行なうことがわかる。
　
　たとえば、上の図では、待ち状態において相手からokが送られてきたときの遷移が定義されていない。
　定義されていないものは無視するとしたほうが良いだろう。
　
　また、自分の状態×相手から送られてきたメッセージ　に　よって遷移していくので、これは
　状態の遷移のマトリクスを作成すればよい。
　
　具体的には、
　	Delegate[自分の状態][相手の状態] maps;
　のようなもので管理すればコーディングしやすいだろう。
　
